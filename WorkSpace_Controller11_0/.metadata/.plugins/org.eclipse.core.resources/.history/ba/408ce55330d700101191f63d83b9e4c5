


//======================================================
// Handshake.c
//======================================================
//======================================================
// handshake.c
//======================================================
#include "vl53l0x.h"
#include <stdio.h>
#include <string.h>
#include <math.h>
#include "Inc/Handshake.h"


// =======================
// I2C BUS RECOVERY
// =======================
HAL_StatusTypeDef I2C_Recover(I2C_HandleTypeDef *hi2c)
{
    // 필요한 경우 I2C 강제 리셋 및 재초기화
    return HAL_OK;
}

// =======================
// I2C 디바이스 스캔
// =======================
void I2C_DumpDevices(I2C_HandleTypeDef *hi2c)
{
    for (uint16_t addr = 1; addr < 128; addr++)
    {
        HAL_StatusTypeDef st = HAL_I2C_IsDeviceReady(hi2c, addr << 1, 1, 5);
        if (st == HAL_OK)
        {
            char buf[64];
            snprintf(buf, sizeof(buf), "I2C Device Found: 0x%02X", addr);
            LOG("[I2C]", buf);
        }
    }
}

// =======================
// 센서 체크 함수
// =======================
bool CheckSIM(void)
{
    if (SIM_Wakeup(3000) != 0)
    {
        error_code += 1;
        LOG("[ERR]", "SIM_FAIL");
        return false;
    }
    LOG("[ANS]", "SIM_OK");
    return true;
}

bool CheckLaser(void)
{
    if (VL53L0X_OFFSET(&distanceStr) == -1.0f)
    {
        error_code += 10;
        LOG("[ERR]", "LASER_FAIL");
        return false;
    }
    LOG("[ANS]", "LASER_OK");
    return true;
}

bool CheckUltra(void)
{
    float ultra_val = Ultra_ReadDistance();
    if (ultra_val == -1.0f)
    {
        error_code += 100;
        LOG("[ERR]", "ULTRA_FAIL");
        return false;
    }
    LOG("[ANS]", "ULTRA_OK");
    return true;
}

bool CheckLoadcell(void)
{
    if (HX711_Tare(&scale1, 10, 2000) == -1.0f ||
        HX711_Tare(&scale2, 10, 2000) == -1.0f)
    {
        error_code += 1000;
        LOG("[ERR]", "LOADCELL_FAIL");
        return false;
    }
    LOG("[ANS]", "LOADCELL_OK");
    return true;
}

bool CheckWater(void)
{
    if (WATER_ReadLastOn_Quick(220) < 0)
    {
        error_code += 10000;
        LOG("[ERR]", "WATER_FAIL");
        return false;
    }
    LOG("[ANS]", "WATER_OK");
    return true;
}

// =======================
// HANDSHAKE (메인)
// =======================
void Handshake(void)
{
    error_code = 0;
    LOG("[SYS]", "HANDSHAKE START");

    // LED 디버깅
    for (int i = 0; i < 10; i++)
    {
        HAL_GPIO_TogglePin(LED_GPIO_Port, LED_Pin);
        HAL_Delay(100);
    }

    // 센서 전원 ON
    HAL_GPIO_WritePin(DEVICE_GPIO_Port, DEVICE_Pin, GPIO_PIN_RESET);
    HAL_Delay(50);

    // 센서 초기화
    initVL53L0X(1, &hi2c1);

    HX711_Init(&scale1, LC_Data1_GPIO_Port, LC_Data1_Pin,
               LC_SCK_GPIO_Port, LC_SCK_Pin, calibration_factor);
    HX711_Init(&scale2, LC_Data2_GPIO_Port, LC_Data2_Pin,
               LC_SCK_GPIO_Port, LC_SCK_Pin, calibration_factor);

    // 센서 체크
    CheckSIM();
    CheckLaser();
    CheckUltra();
    CheckLoadcell();
    CheckWater();

    // 최종 상태 로깅
    if (error_code == 0)
        LOG("[ANS]", "ALL_OK");
    else
        LOG("[ANS]", "SYSTEM_FAIL");

    // HX711 측정값 읽기
    loadcell_1_handshake = HX711_Get_Value(&scale1, 10, 2000);
    loadcell_2_handshake = HX711_Get_Value(&scale2, 10, 2000);

    // SIM Sleep
    SIM_Sleep(300);

    LOG("[SYS]", "HANDSHAKE END");
    FUNCTION = SPACE;
}


//======================================================
//                    LEGACY CODE
//======================================================
////for debug and fail device checking
//uint16_t error_code = 0;
//char error_code_char[10];
//
//for (int i = 0; i < 10; i++) {
//	HAL_GPIO_TogglePin(LED_GPIO_Port, LED_Pin);
//	HAL_Delay(100); // 0.1sec delay
//}
//HAL_GPIO_WritePin(DEVICE_GPIO_Port, DEVICE_Pin, GPIO_PIN_RESET); //Turn on sensor
//initVL53L0X(1, &hi2c1);
//HX711_Init(&scale1, LC_Data1_GPIO_Port, LC_Data1_Pin,
//LC_SCK_GPIO_Port, LC_SCK_Pin, calibration_factor);
//HX711_Init(&scale2, LC_Data2_GPIO_Port, LC_Data2_Pin,
//LC_SCK_GPIO_Port, LC_SCK_Pin, calibration_factor);
//
//ultra = Ultra_ReadDistance();
//
//if (SIM_Wakeup(800) != 0) {
//	error_code += 1;
//} else {
//	LOG("[ANS]", "SIM_OK");
//}
//
//if (VL53L0X_OFFSET(&distanceStr) == -1.0f) {
//	error_code += 10;
//} else {
//	LOG("[ANS]", "LASER_OK");
//}
//
//if (ultra == -1.0f) {
//	error_code += 100;
//} else if (ultra != -1.0f) {
//	LOG("[ANS]", "ULTRA_OK");
//	if ((ultra <= 20.0)
//			&& (ultra >= 0)) {
//		LOG("[ANS]", "FULL");
//	}
//}
//
//if (HX711_Tare(&scale1, 1, 100) == -1.0f || HX711_Tare(&scale2, 1, 100) == -1.0f) {
//	error_code += 1000;
//	if (HX711_Get_Value(&scale1, 30, 2000) == -1.0f
//			|| HX711_Get_Value(&scale2, 30, 2000) == -1.0f) {
//		if (HX711_Get_Value(&scale1, 30, 2000) == -1.0f) {
//		} else {
//			LOG("[ANS]", "LC1_OK");
//		}
//		if (HX711_Get_Value(&scale2, 30, 2000) == -1.0f) {
//		} else {
//			LOG("[ANS]", "LC2_OK");
//		}
//	}
//}
//
//if (WATER_ReadLastOn_Quick(200) == -1.0f) {
//	error_code += 10000;
//} else {
//	LOG("[ANS]", "WS_OK");
//}
//
//if (error_code == 0) {
//	LOG("[ANS]", "OK");
//} else {
//	// I2C 상태 점검
//	for (uint16_t addr = 1; addr < 128; addr++) {
//		HAL_StatusTypeDef status = HAL_I2C_IsDeviceReady(&hi2c1, addr << 1, 1, 5);
//		// I2C HAL 상태가 HAL_OK라면 I2C 주소 출력
//		if (status == HAL_OK) {
//			snprintf(i2c_check_buf, sizeof(i2c_check_buf), "I2C Device Found: 0x%02X\r\n", addr);
//			LOG("[I2C]", i2c_check_buf);
//		// I2C HAL 상태가 HAL_BUSY 상태라면
//		} else if (status == HAL_BUSY) {
//			LOG("[I2C]", i2c_check_buf);
//			LOG("[I2C]", "HAL_BUSY\r\n");
//			// 100번을 채우거나 HAL_OK가 될때까지 루프를 돈다.
//			for (int i = 0; i < 100; i++) {
//				// I2C 비활성화
//				HAL_I2C_DeInit();
//				// I2C1 하드웨어 강제 리셋
//				__HAL_RCC_I2C1_FORCE_RESET();
//				HAL_Delay(10);
//				LOG("[I2C]", "FORCE_RST_TRYING...");
//				// I2C1이 강제 리셋되었다면
//				if (RCC->APB1RSTR & RCC_APB1RSTR_I2C1RST) {
//					LOG("[I2C]", "I2C1_RESET_BIT_ON");
//					LOG("[I2C]", "RELEASE_RST_TRYING...");
//					// I2C1 리셋 해제
//					__HAL_RCC_I2C1_RELEASE_RESET();
//					// I2C1 리셋 해제가 되었다면
//					if ((RCC->APB1RSTR & RCC_APB1RSTR_I2C1RST) == 0) {
//						LOG("[I2C]", "I2C1_RESET_BIT_OFF");
//						LOG("[I2C]", "I2C1_RESET_SUCCESS");
//						// HAL_I2C 활성화
//						HAL_I2C_Init();
//						// 안정화 DELAY
//						HAL_Delay(10);
//						// HAL_I2C 초기화 후 상태가 HAL_OK가 아니라면
//						if (HAL_I2C_Init(&hi2c1) != HAL_OK) {
//							LOG("[I2C]", "HAL_INIT_FAIL");
//							continue;   // 다음 루프 계속 진행
//						} else {
//							LOG("[I2C]", "HAL_INIT_OK");
//						}
//					}
//				} else {
//					LOG("[I2C1_RST]", "I2C1_RESET_FAIL");
//				}
//
//				status = HAL_I2C_IsDeviceReady(&hi2c1, addr << 1, 1, 5);
//
//				if (status == HAL_OK) {
//					break;
//				}
//			}
//
//		} else if (status == HAL_TIMEOUT) {
//			LOG("[I2C]", "HAL_TIMEOUT\r\n");
//			__HAL_RCC_I2C1_FORCE_RESET();
//			HAL_Delay(10);
//			if (RCC->APB1RSTR & RCC_APB1RSTR_I2C1RST) {
//			__HAL_RCC_I2C1_RELEASE_RESET();
//			} else {
//				LOG("[I2C1_RST]", "I2C1_RESET_ERROR");
//			}
//			HAL_I2C_DeInit(&hi2c1);
//			HAL_Delay(10);
//			HAL_I2C_Init(&hi2c1);
//
//			status = HAL_I2C_IsDeviceReady(&hi2c1, addr << 1, 1, 5);
//		}
//	}
//
//	i2c_check_buf[0] = 0;
//
//	snprintf(error_code_char, sizeof(error_code_char), "%d",
//			error_code);
//
////					LOG("[ANS]", "FAIL");
//
//	LOG("[DEBUG]", error_code_char);
//
//	// SIM FAIL (1)
//	if (error_code % 10 == 1) {
//		LOG("[ERR]", "SIM_FAIL");
//	}
//
//	// LASER FAIL (10)
//	if ((error_code / 10) % 10 == 1) {
//		LOG("[ERR]", "LASER_FAIL");
//	}
//
//	// ULTRA FAIL (100)
//	if ((error_code / 100) % 10 == 1) {
//		LOG("[ERR]", "ULTRA_FAIL");
//	}
//
//	// LOAD CELL FAIL (1000)
//	if ((error_code / 1000) % 10 == 1) {
//		LOG("[ERR]", "LOADCELL_FAIL");
//	}
//
//	// WATER SENSOR FAIL (10000)
//	if ((error_code / 10000) % 10 == 1) {
//		LOG("[ERR]", "WATER_SENSOR_FAIL");
//	}
//
//	error_code = 0;
//}
//
//HAL_Delay(100);
//
//loadcell_1_handshake = HX711_Get_Value(&scale1, 10, 2000);
//loadcell_2_handshake = HX711_Get_Value(&scale2, 10, 2000);
//
//SIM_Sleep(300);
//FUNCTION = SPACE;
