//======================================================
// CloseInput.c (Fixed & Structured Version)
//======================================================



//======================================================
//                    LEGACY CODE
//======================================================
///*Control motor*/
//HAL_GPIO_WritePin(Door_IN1_GPIO_Port, Door_IN1_Pin,
//		GPIO_PIN_RESET);
//HAL_GPIO_WritePin(Door_IN2_GPIO_Port, Door_IN2_Pin,
//		GPIO_PIN_SET);
//
//HAL_Delay(30000);
//
//for (uint16_t addr = 1; addr < 128; addr++) {
//
//	HAL_StatusTypeDef status = HAL_I2C_IsDeviceReady(&hi2c1,
//			addr << 1, 1, 5);
//
//	if (status == HAL_OK) {
//
//		snprintf(i2c_check_buf, sizeof(i2c_check_buf),
//				"I2C Device Found: 0x%02X\r\n", addr);
//
//		LOG("[I2C]", i2c_check_buf);
//	} else if (status == HAL_BUSY) {
//		LOG("[I2C]", "HAL_BUSY\r\n");
//		__HAL_RCC_I2C1_FORCE_RESET();
//		if (__HAL_RCC_I2C1_FORCE_RESET()) {
//			__HAL_RCC_I2C1_RELEASE_RESET();
//		} else {
//			LOG("[I2C1_RST]", "I2C1_RESET_ERROR");
//		}
//
//	} else if (status == HAL_TIMEOUT) {
//		LOG("[I2C]", "HAL_TIMEOUT\r\n");
//		__HAL_RCC_I2C1_FORCE_RESET();
//		if (__HAL_RCC_I2C1_FORCE_RESET()) {
//			__HAL_RCC_I2C1_RELEASE_RESET();
//		} else {
//			LOG("[I2C1_RST]", "I2C1_RESET_ERROR");
//		}
//	}
//}
//
///*Take value from sensor*/
//// load cell and tof sensor
//if (VL53L0X_ReadDistance(&distanceStr, offset_DistanceTof)
//		== -1.0f) {
//	LOG("[ANS]", "DIST_FAIL");
//} else {
//	LOG("[ANS]", "DIST_SUCC");
//}
//
//if (HX711_Get_Value(&scale1, 30, 2000) == -1.0f) {
//	LOG("[ANS]", "LC1_FAIL");
//} else {
//	LOG("[ANS]", "LC1_SUCC");
//}
//
//if (HX711_Get_Value(&scale2, 30, 2000) == -1.0f) {
//	LOG("[ANS]", "LC2_FAIL");
//} else {
//	LOG("[ANS]", "LC2_SUCC");
//}
//
//if (WATER_ReadLastOn_Quick(200) == -1.0f) {
//	LOG("[ANS]", "WS_FAIL");
//} else {
//	LOG("[ANS]", "WS_SUCC");
//}
//
//distance_Tof = VL53L0X_ReadDistance(&distanceStr,
//		offset_DistanceTof); //(mm)
//
//loadcell_1_close = HX711_Get_Value(&scale1, 30, 2000);
//loadcell_2_close = HX711_Get_Value(&scale2, 30, 2000);
//
//loadcell_1_door = loadcell_1_close - loadcell_1_open;
//loadcell_2_door = loadcell_2_close - loadcell_2_open;
//
//if (fabsf(loadcell_1_door) < 5.0f)
//	loadcell_1_door = 0.0f;
//if (fabsf(loadcell_2_door) < 5.0f)
//	loadcell_2_door = 0.0f;
//
//loadcell_sum = loadcell_1_door + loadcell_2_door;
//
//// Total mass using interpolation table HX711 (LC1 + LC2)
//lc_mass = HX711_InterpFromTable(loadcell_sum);   // g 단위
//
//watersensor_value = WATER_ReadHeightMM(220);   //(mm)
//water_weight = WATER_ReadLastOn_Quick(220);     //last_on index
//
///*Turn off the sensor*/
//HAL_GPIO_WritePin(DEVICE_GPIO_Port, DEVICE_Pin, GPIO_PIN_SET);
//
////Transmit to header
//oil_weight = lc_mass - water_weight;
//if (oil_weight < 0.0f)
//	oil_weight = 0.0f;
//
//memset(data_TransmitHeader, '\0', sizeof(data_TransmitHeader));
//snprintf(data_TransmitHeader, 40, "O%.2fW%.2fE", oil_weight,
//		water_weight);
//LOG("[ANS]", data_TransmitHeader);
//
//// (1) HX711 Original value
//snprintf(data_TransmitHeader, sizeof(data_TransmitHeader),
//		"Distance=%.2f mm, LC1_raw=%.2f, LC2_raw=%.2f;",
//		distance_Tof, loadcell_1_door, loadcell_2_door);
//LOG("[ANS]", data_TransmitHeader);
//// (1) HX711 Original value
//snprintf(data_TransmitHeader, sizeof(data_TransmitHeader),
//		"lc1_open=%.2f g, lc2_open=%.2f g, lc1_close=%.2f g, lc2_close=%.2f g;",
//		loadcell_1_open, loadcell_2_open, loadcell_1_close,
//		loadcell_2_close);
//LOG("[ANS]", data_TransmitHeader);
//// (2) Total mass that brought by interpolation table vs Water weight that sensed by water sensor.
//snprintf(data_TransmitHeader, sizeof(data_TransmitHeader),
//		"LC_mass=%.1f g, WS_mass=%.1f g, Oil_mass=%.1f g;",
//		lc_mass, water_weight, oil_weight);
//LOG("[ANS]", data_TransmitHeader);
//
//FUNCTION = SPACE;
